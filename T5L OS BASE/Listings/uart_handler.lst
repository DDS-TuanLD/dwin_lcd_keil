C51 COMPILER V9.57.0.0   UART_HANDLER                                                      05/08/2021 13:18:32 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE UART_HANDLER
OBJECT MODULE PLACED IN .\Objects\uart_handler.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Sources\uart_handler.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND
                    - PRINT(.\Listings\uart_handler.lst) TABS(2) OBJECT(.\Objects\uart_handler.obj)

line level    source

   1          #include "uart_handler.h"
   2          #include "lcd_handler.h"
   3          #include "uart.h"
   4          #include "dgus.h"
   5          #include "user_fifo.h"
   6          #include "tstring.h"
   7          #include "dgus.h"
   8          #include "norflash.h"
   9          
  10          
  11          uint8_t reset_data[2] = {0x00, 0x00};
  12          uint8_t last_scene_call[2] = {0};
  13          uint8_t scene_call[2] = {0};
  14          uint8_t reset_module[2] = {0};
  15          uart_mess_t uart_last_mess_sent = {0};
  16          
  17          uint8_t create_crc_check(uint8_t *d){
  18   1        int i = 0;
  19   1        uint16_t temp = 0;
  20   1        for(i=2; i<7; i++){
  21   2          temp = temp + d[i];
  22   2        }
  23   1        return temp & 0x00ff;
  24   1      }
  25          
  26          uint8_t is_uart_mess_response_waiting(){
  27   1        return uart_last_mess_sent.flag;
  28   1      }
  29          
  30          void lcd_scene_call_send_uart(uint8_t btn, uint8_t ack){
  31   1        uint8_t scall_uart_send_dt[UART_DATA_MAX_LEN] = {0};
  32   1        int count = 0;
  33   1      
  34   1        scall_uart_send_dt[0] = UART_HEADER_DATA_0;
  35   1        count = count + 1;
  36   1      
  37   1        scall_uart_send_dt[1] = UART_HEADER_DATA_1;
  38   1        count = count + 1;
  39   1        
  40   1        scall_uart_send_dt[2] = UART_HMI_TO_MODULE;
  41   1        count = count + 1;
  42   1        
  43   1        scall_uart_send_dt[3] = UART_TYPE_CMD;
  44   1        count = count + 1;
  45   1      
  46   1        scall_uart_send_dt[4] = LCD_CALL_SCENE_CMD >> 8;
  47   1        count = count + 1;
  48   1      
  49   1        scall_uart_send_dt[5] = LCD_CALL_SCENE_CMD & 0x00ff;
  50   1        count = count + 1;
  51   1      
  52   1        scall_uart_send_dt[6] = 0x01;
  53   1        count = count + 1;
  54   1      
C51 COMPILER V9.57.0.0   UART_HANDLER                                                      05/08/2021 13:18:32 PAGE 2   

  55   1        scall_uart_send_dt[7] = btn;
  56   1        count = count + 1;
  57   1      
  58   1        scall_uart_send_dt[8] = create_crc_check(scall_uart_send_dt);
  59   1        count = count + 1;
  60   1        
  61   1        t_strcpy(uart_last_mess_sent.dt, scall_uart_send_dt, count);
  62   1        uart_last_mess_sent.len = count;
  63   1        uart_last_mess_sent.flag = ack;
  64   1        
  65   1        Uart2SendStr(uart_last_mess_sent.dt, uart_last_mess_sent.len);
  66   1      }
  67          
  68          void lcd_scene_call_handler(uint8_t *dt, uint8_t ack){
  69   1        
  70   1        lcd_scene_call_send_uart(dt[1], ack);
  71   1      }
  72          
  73          void lcd_send_scene_call_uart_process(){
  74   1        ReadDGUS(LCD_CALL_SCENE_ADR, scene_call, 2);
  75   1        if(scene_call[1] == 0){
  76   2          
  77   2        }else{
  78   2          lcd_scene_call_handler(scene_call, UART_TYPE_CMD);
  79   2          WriteDGUS(LCD_CALL_SCENE_ADR, reset_data, 2);
  80   2        }
  81   1        
  82   1        ReadDGUS(LCD_RESET_MODULE_ADR, reset_module, 2);
  83   1        if((reset_module[0] == 0) && (reset_module[1] == 0)){
  84   2        
  85   2        }else{
  86   2          lcd_send_reset_cmd_to_module();
  87   2          reset_module[0] = reset_module[1] = 0;
  88   2          WriteDGUS(LCD_RESET_MODULE_ADR, reset_module, 2);
  89   2        }
  90   1        return;
  91   1      }
  92          
  93          uint16_t get_valid_data_header_loc(){
  94   1        uint16_t count = 0;
  95   1        uint16_t i = 0;
  96   1        uint16_t i1;
  97   1        uint16_t i2;
  98   1        uint16_t i3;
  99   1        uint16_t r_point = user_fifo_get_r_point();
 100   1        while (count <= user_fifo_get_number_bytes_written())
 101   1        {
 102   2          i1 = (i + r_point);
 103   2          i2 = (i + r_point + 1);
 104   2          i3 = (i + r_point + 2);
 105   2          if(i1 > MAX_QUEUE_LEN -1){
 106   3            i1 = i1 - MAX_QUEUE_LEN;
 107   3          }
 108   2          if(i2 > MAX_QUEUE_LEN -1){
 109   3            i2 = i2 - MAX_QUEUE_LEN;
 110   3          }if(i1 > MAX_QUEUE_LEN -1){
 111   3            i3 = i3 - MAX_QUEUE_LEN;
 112   3          }
 113   2          if((user_fifo_get(i1) == UART_HEADER_DATA_0) && (user_fifo_get(i2) == UART_HEADER_DATA_0) && (user_fifo_
             -get(i3) == UART_HMI_TO_MODULE) && (i1 != r_point)){
 114   3            return i;
 115   3          }
C51 COMPILER V9.57.0.0   UART_HANDLER                                                      05/08/2021 13:18:32 PAGE 3   

 116   2          i = i + 1;
 117   2          count = count + 1;
 118   2          if(i == MAX_QUEUE_LEN){
 119   3            i = 0;
 120   3          }
 121   2        }
 122   1        return 0xffff;
 123   1      }
 124          
 125          int is_reiv_data_valid(uint8_t *dt, uint16_t len){
 126   1        if((dt[0] == UART_HEADER_DATA_0) && (dt[1] == UART_HEADER_DATA_1) && (dt[2] == UART_MODULE_TO_HMI) && (dt
             -[len-1] == create_crc_check(dt))){
 127   2          return 1;
 128   2        }
 129   1        return 0;
 130   1      }
 131          
 132          void parse_uart_data(uart_parse_data *p_data, uint8_t *dt){
 133   1        int i;
 134   1        int j = 0;
 135   1        p_data->dt_len = dt[6];
 136   1        for(i = 7; i< 7 + dt[6]; i++){
 137   2          p_data->dt[j] = dt[i];
 138   2          j = j + 1;
 139   2        } 
 140   1        return;
 141   1      }
 142          
 143          void uart_data_handler(uint8_t *dt, uint16_t len){
 144   1        uint16_t act_reiv = dt[4] << 8 | dt[5];
 145   1        uart_parse_data p_data = {0};
 146   1        if(is_uart_mess_response_waiting()){
 147   2          uint16_t temp = uart_last_mess_sent.dt[4] << 8 | uart_last_mess_sent.dt[5];
 148   2          if(!is_reiv_data_valid(dt, len)){
 149   3            Uart2SendStr(uart_last_mess_sent.dt, uart_last_mess_sent.len);
 150   3            uart_last_mess_sent.sent_count = uart_last_mess_sent.sent_count + 1;
 151   3            if(uart_last_mess_sent.sent_count > 5){
 152   4              uart_last_mess_sent.flag = 0;
 153   4              uart_last_mess_sent.sent_count = 0;
 154   4            }
 155   3            return;
 156   3          }
 157   2          if((temp == act_reiv) && (dt[3] == UART_TYPE_RES) && (len == uart_last_mess_sent.len)){
 158   3            uart_last_mess_sent.flag = 0;
 159   3            uart_last_mess_sent.sent_count = 0;
 160   3          }else{
 161   3            Uart2SendStr(uart_last_mess_sent.dt, uart_last_mess_sent.len);
 162   3            uart_last_mess_sent.sent_count = uart_last_mess_sent.sent_count + 1;
 163   3            if(uart_last_mess_sent.sent_count > 5){
 164   4              uart_last_mess_sent.flag = 0;
 165   4              uart_last_mess_sent.sent_count = 0;
 166   4            }
 167   3          }
 168   2          return;
 169   2        }else{
 170   2          uint16_t humi;
 171   2          uint8_t time_data[2] = {0};
 172   2          uint8_t temp_data[2] = {0};
 173   2          uint8_t humi_data[2] = {0};
 174   2          if(!is_reiv_data_valid(dt, len)){
 175   3            return;
 176   3          }
C51 COMPILER V9.57.0.0   UART_HANDLER                                                      05/08/2021 13:18:32 PAGE 4   

 177   2          if(dt[3] == UART_TYPE_CMD){
 178   3            dt[2] = UART_HMI_TO_MODULE;
 179   3            dt[3] = UART_TYPE_RES;
 180   3            dt[len - 1] = create_crc_check(dt);
 181   3            Uart2SendStr(dt, len);
 182   3          }
 183   2        
 184   2          parse_uart_data(&p_data, dt);
 185   2          switch (act_reiv){
 186   3            case LCD_UPDATE_SENSOR_PARA_CMD :
 187   3              humi = p_data.dt[2] << 8 | p_data.dt[3];
 188   3              temp_data[0] = p_data.dt[0];
 189   3              temp_data[1] = p_data.dt[1];
 190   3              humi_data[0] = humi/10;
 191   3              humi_data[1] = humi%10;
 192   3              WriteDGUS(LCD_UPDATE_TEM_ADR, temp_data, 2);
 193   3              WriteNorFlash(LCD_TEM_SAVE_ADR, LCD_UPDATE_TEM_ADR, 2);
 194   3              WriteDGUS(LCD_UPDATE_HUM_ADR, humi_data, 2);
 195   3              WriteNorFlash(LCD_HUM_SAVE_ADR, LCD_UPDATE_HUM_ADR, 2);       
 196   3              break;
 197   3            case LCD_UPDTE_TIME_CMD : 
 198   3              time_data[0] = p_data.dt[0];
 199   3              time_data[1] = p_data.dt[1];
 200   3              WriteDGUS(LCD_UPDTE_TIME_ADR, time_data, 2);
 201   3              WriteNorFlash(LCD_TIM_SAVE_ADR, LCD_UPDTE_TIME_ADR, 2);
 202   3              break;
 203   3            default:
 204   3              break;
 205   3          }
 206   2        }
 207   1        return;
 208   1      }
 209          
 210          void lcd_send_reset_cmd_to_module(){
 211   1          uint8_t scall_uart_send_dt[UART_DATA_MAX_LEN] = {0};
 212   1        int count = 0;
 213   1      
 214   1        scall_uart_send_dt[0] = UART_HEADER_DATA_0;
 215   1        count = count + 1;
 216   1      
 217   1        scall_uart_send_dt[1] = UART_HEADER_DATA_1;
 218   1        count = count + 1;
 219   1        
 220   1        scall_uart_send_dt[2] = UART_HMI_TO_MODULE;
 221   1        count = count + 1;
 222   1        
 223   1        scall_uart_send_dt[3] = UART_TYPE_CMD;
 224   1        count = count + 1;
 225   1      
 226   1        scall_uart_send_dt[4] = LCD_RESET_MODULE_CMD >> 8;
 227   1        count = count + 1;
 228   1      
 229   1        scall_uart_send_dt[5] = LCD_RESET_MODULE_CMD & 0x00ff;
 230   1        count = count + 1;
 231   1      
 232   1        scall_uart_send_dt[6] = 0x00;
 233   1        count = count + 1;
 234   1      
 235   1        scall_uart_send_dt[8] = create_crc_check(scall_uart_send_dt);
 236   1        count = count + 1;
 237   1        
 238   1        t_strcpy(uart_last_mess_sent.dt, scall_uart_send_dt, count);
C51 COMPILER V9.57.0.0   UART_HANDLER                                                      05/08/2021 13:18:32 PAGE 5   

 239   1        uart_last_mess_sent.len = count;
 240   1        uart_last_mess_sent.flag = 0x01;
 241   1        
 242   1        Uart2SendStr(uart_last_mess_sent.dt, uart_last_mess_sent.len);
 243   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1968    ----
   CONSTANT SIZE    =     89    ----
   XDATA SIZE       =     41     136
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
